<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>2020年5月面试纪要 | 一介码农</title>
<link rel="shortcut icon" href="https://zhi-he.github.io/favicon.ico?v=1589349744690">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://zhi-he.github.io/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="2020年5月面试纪要 | 一介码农 - Atom Feed" href="https://zhi-he.github.io/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">



    <meta name="description" content="前言
今天面了一家国企，具体哪家公司就不提了😂。本人17年毕业，但是16年底就在目前的公司一直工作，面试环节可以说是薄弱的可怜😪。面试官直指痛点，技术可以，但是表述不清楚。面试嘛，大部分都是聊着造火箭的技术，到公司之后拧螺丝。但是没办法..." />
    <meta name="keywords" content="前端,面试" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://zhi-he.github.io">
  <img class="avatar" src="https://zhi-he.github.io/images/avatar.png?v=1589349744690" alt="">
  </a>
  <h1 class="site-title">
    一介码农
  </h1>
  <p class="site-description">
    温故而知新
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          首页
        </a>
      
    
      
        <a href="/archives" class="menu">
          归档
        </a>
      
    
      
        <a href="/tags" class="menu">
          标签
        </a>
      
    
      
        <a href="/post/about" class="menu">
          关于
        </a>
      
    
  </div>
  <div class="social-container">
    
      
    
      
    
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              2020年5月面试纪要
            </h2>
            <div class="post-info">
              <span>
                2020-05-12
              </span>
              <span>
                10 min read
              </span>
              
                <a href="https://zhi-he.github.io/tag/InMpVVPPm/" class="post-tag">
                  # 前端
                </a>
              
                <a href="https://zhi-he.github.io/tag/t9PNOe_V3-/" class="post-tag">
                  # 面试
                </a>
              
            </div>
            
              <img class="post-feature-image" src="https://zhi-he.github.io/post-images/2020-nian-5-yue-mian-shi-ji-yao-vue.jpg" alt="">
            
            <div class="post-content-wrapper">
              <div class="post-content">
                <h1 id="前言">前言</h1>
<p>今天面了一家国企，具体哪家公司就不提了😂。本人17年毕业，但是16年底就在目前的公司一直工作，面试环节可以说是薄弱的可怜😪。面试官直指痛点，技术可以，但是表述不清楚。面试嘛，大部分都是聊着造火箭的技术，到公司之后拧螺丝。但是没办法，这是现实。因此我努力回忆起了一些今天面试的内容，整理一下用作记录，接下来步入正题。</p>
<ul>
<li>注意</li>
</ul>
<blockquote>
<p>本文偏重理论和原理，没有过多的代码和图解，读起来可能有些枯燥，刚开始写博客，多多批评！😝</p>
</blockquote>
<h1 id="面试主要内容">面试主要内容：</h1>
<ol>
<li>SPA应用性能优化</li>
<li>插槽的使用</li>
<li>子父组件生命周期的加载顺序</li>
<li><code>history</code>和<code>hash</code>区别以及原理</li>
<li>ES6的map使用</li>
<li>聊一下ES5和ES6继承</li>
<li>兄弟组件如何传值</li>
<li><code>vuex</code>如果实现状态管理，详细描述一下实现过程</li>
</ol>
<h2 id="暂时只能回想起这么多看到这里你是否和我一样觉得这些都是我们日常用到的但是深究其底层原理又觉得好像只能说点皮毛-没关系下面是我整理的资料希望对各位再次面试的时候有用">** 暂时只能回想起这么多，看到这里你是否和我一样觉得这些都是我们日常用到的，但是深究其底层原理，又觉得好像只能说点皮毛。没关系，下面是我整理的资料，希望对各位再次面试的时候有用！**</h2>
<h1 id="面试题目解析">面试题目解析</h1>
<h2 id="1-前端性能优化">1. 前端性能优化</h2>
<h3 id="减小代码体积">减小代码体积</h3>
<h4 id="首先是开发时我们主要对自己代码的执行有认知怎么写才能做到代码量最小并且执行的更快">首先是开发时，我们主要对自己代码的执行有认知，怎么写，才能做到代码量最小并且执行的更快。</h4>
<ul>
<li><code>v-if</code>和<code>v-show</code>，v-if是惰性的，只有条件为真的时候才会渲染，v-show是只要执行到此处，就会渲染元素，区分场景</li>
<li><code>computed</code> 和 <code>watch</code>，<code>computed</code>依赖其他数据进行数值计算，避免每次获取值时重新计算；<code>watch</code>是对数据的监听，对数据操作过多时，允许执行异步操作，限制操作频率，设置中间态。</li>
<li><code>v-for</code>遍历，务必为<code>item</code> 添加<code>key</code>，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 <code>diff</code> ；且<code>v-for</code>比 <code>v-if</code>优先级高，尽量在<code>v-for</code>中使用<code>v-if</code>以为可能只修改一个值，就需要遍历整个数据表，严重影响速度</li>
<li>图片资源懒加载，使用 vue-lazyload</li>
<li>路由懒加载，避免首页首页长时间白屏，开发路由时使用 <code>import('./***.vue')</code></li>
<li>第三方插件的按需引入，使用 babel-plugin-component</li>
</ul>
<h4 id="其次就是-webpack-为我们提供的方法我们尽管使用即可">其次就是 <code>webpack</code> 为我们提供的方法，我们尽管使用即可</h4>
<ul>
<li>对图片进行压缩，使用 <code>image-webpack-loader</code></li>
<li>提取公共代码，Webpack 内置了专门用于提取多个Chunk 中的公共部分的插件 <code>CommonsChunkPlugin</code></li>
<li>优化 <code>SourceMap</code>，具体看vue文档吧</li>
</ul>
<h4 id="web基础优化">web基础优化</h4>
<ul>
<li>服务端开启gzip压缩</li>
<li>对静态资源进行浏览器缓存</li>
<li>利用CDN从服务器上下载 CSS、js 和图片等文件时</li>
</ul>
<h2 id="2-插槽">2. 插槽</h2>
<p>插槽就是Vue实现的一套内容分发的API，将<code>&lt;slot&gt;&lt;/slot&gt;</code>元素作为承载分发内容的出口。<br>
* 普通插槽，当子组件绝大部分内容是固定的，只有局部内容变化，这时候可用插槽来实现<br>
* 具名插槽，有时一个组件中部分内容固定的，但是其他部分分好几个模块变化，这时候可用具名，插槽在slot中添加name来为这个组件来添加多个插槽<br>
* 作用域插槽，正常来讲父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的。但是我们又希望在插槽中获取子组件中的数据，这时为了实现在父级的插槽内容中可用，我们可以将子组件的数据作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去。绑定在<code>&lt;slot&gt;</code> 元素上的 <code>attribute</code> 被称为插槽 <code>prop</code>。</p>
<h2 id="3-子父组件生命周期的加载顺序">3. 子父组件生命周期的加载顺序</h2>
<ul>
<li>父组件<code>beforeCreated</code></li>
<li>父组件<code>created</code></li>
<li>父组件<code>beforeMounted</code></li>
<li>子组件<code>beforeCreated</code></li>
<li>子组件<code>created</code></li>
<li>子组件<code>beforeMounted</code></li>
<li>子组件<code>mounted</code></li>
<li>父组件<code>mounted</code></li>
</ul>
<blockquote></blockquote>
<p>注意：<br>
父组件的<code>mounted</code>是在最后执行的。<br>
因此在子组件的 <code>mounted</code> 中渲染父组件在 <code>mounted</code> 阶段请求的数据，是会无反应的。因为子组件 <code>mounted</code> 渲染数据会发生在父组件 <code>mounted</code> 请求数据之前。</p>
<h2 id="4-history-和-hash-区别以及原理">4. <code>history</code> 和 <code>hash</code> 区别以及原理</h2>
<ul>
<li><code>hash</code>，即地址栏 URL 中的 #。比如这个 URL：http://www.abc.com/#/hello，hash 的值为 #/hello。它的特点在于：hash 虽然出现在 URL 中，但不会被包括在 HTTP 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。</li>
<li><code>history</code>，利用了 HTML5 History Interface 中新增的 pushState() 和 replaceState() 方法。（需要特定浏览器支持）这两个方法应用于浏览器的历史记录栈，在当前已有的 back、forward、go 的基础之上，它们提供了对历史记录进行修改的功能。只是当它们执行修改时，虽然改变了当前的 URL，但浏览器不会立即向后端发送请求。<br>
** 因此可以说，hash 模式和 history 模式都属于浏览器自身的特性，Vue-Router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现前端路由。 **</li>
</ul>
<h4 id="两者对比">两者对比</h4>
<pre><code>1. `pushState()` 的URL可以是当前URL同源的任意URL；而 `hash` 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL
2. 在浏览器的URL入栈时，`pushState()`可以是相同的URL，`hash` 必须和当前的不一样才行
3. 在用URL传参时，`pushState() `通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串
4. `history` 模式下，需要运维对页面路由进行处理，否则切换白屏
</code></pre>
<h2 id="5-es6的map">5. ES6的map</h2>
<p><code>map</code> 和 <code>set</code> 都是ES6新增的数据结构，<code>map</code>类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object 结构提供了“字符串—值”的对应，Map 结构提供了“值—值”的对应；<code>set</code>类似于数组，但是成员的值都是唯一的，没有重复的值。<code>WeakSet</code> 结构与 Set 类似，也是不重复的值的集合。但是，它与 Set 有两个区别。首先，WeakSet 的成员只能是对象，而不能是其他类型的值；其次，WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 WeakSet 之中。</p>
<h2 id="6-聊一下es5和es6继承">6. 聊一下ES5和ES6继承</h2>
<p>ES6 中有类 class 的概念，类 class 的继承是通过 extends 来实现的，ES5 中是通过设置构造函数的 prototype 属性，来实现继承的。</p>
<ul>
<li>ES5继承，构造函数、原型和实例的关系：每一个构造函数都有一个原型对象，每一个原型对象都有一个指向构造函数的指针，而每一个实例都包含一个指向原型对象的内部指针。</li>
<li>ES6继承，class继承，class之间使用extends关键字。子类必须要再 <code>constructor</code> 方法中调用<code>super</code> 方法，否则新建实例会报错，这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工，如果不调用super方法，子类就得不到this对象，注意super关键字指代父类的实例，即父类的this对象。</li>
</ul>
<h2 id="7-组件间如何传值">7. 组件间如何传值</h2>
<ul>
<li>父传子，props</li>
<li>子传父，$emit，或者双向绑定的v-model</li>
<li>非父子组件传值，可以采用发布订阅模式，这种模式在 Vue 中被称为总线机制，或者叫做Bus / 发布订阅模式 / 观察者模式。具体实现如下：
<ol>
<li>首先在Vue的protptype(原型)上挂载了一个名字叫做bus的属性，</li>
</ol>
</li>
</ul>
<pre><code>Vue.prototype.bus = new Vue()，
</code></pre>
<ol start="2">
<li></li>
</ol>
<p>这个属性指向一个Vue的实例，只要以后调用new Vue()或者创建组件的时候每一个组件上都会有一个bus属性.</p>
<pre><code>组件内发送事件：
childclick() {
this.bus.$emit('change', this.content); //content：要发送的数据
}
</code></pre>
<ol start="3">
<li>其他组件接收事件</li>
</ol>
<pre><code>receive(){
this.bus.$on('change', function(msg) {
console.log(msg）; //获取子组件发送的数据
});
}
</code></pre>
<ul>
<li>vuex</li>
</ul>
<h2 id="8-vuex如果实现状态管理详细描述一下实现过程">8. vuex如果实现状态管理，详细描述一下实现过程</h2>
<p>vuex的核心api：<br>
install函数：用来注册插件到vue里（说白了就是在vue中执行这个函数，并把vue当作参数传入此函数，使用vue的方法和绑定store到各个组件上）<br>
store类：state、getters、mutations、actions、modules、plugins<br>
辅助函数：mapState、mapActions、mapMutations</p>
<ul>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。(也就是所谓的MVVM)</li>
<li>你不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutations。</li>
<li>如果是异步的，就派发(dispatch)actions，其本质还是提交mutations</li>
<li>怎样去触发actions呢？可以用组件Vue Components使用dispatch或者后端接口去触发</li>
<li>提交mutations后，可以动态的渲染组件Vue Components</li>
</ul>
<p><img src="https://zhi-he.github.io/post-images/1589349463011.jpg" alt="" loading="lazy"><br>
理解了这张图，就理解了vuex的原理<br>
1）state<br>
state是存储的单一状态，是存储的基本数据。<br>
2）Getters<br>
getters是store的计算属性，对state的加工，是派生出来的数据。就像computed计算属性一样，getter返回的值会根据它的依赖被缓存起来，且只有当它的依赖值发生改变才会被重新计算。<br>
3）Mutations<br>
mutations提交更改数据，使用store.commit方法更改state存储的状态。（mutations同步函数）<br>
4）Actions<br>
actions像一个装饰器，提交mutation，而不是直接变更状态。（actions可以包含任何异步操作）<br>
5）Module<br>
Module是store分割的模块，每个模块拥有自己的state、getters、mutations、actions。</p>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li><a href="#%E5%89%8D%E8%A8%80">前言</a></li>
<li><a href="#%E9%9D%A2%E8%AF%95%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9">面试主要内容：</a>
<ul>
<li><a href="#%E6%9A%82%E6%97%B6%E5%8F%AA%E8%83%BD%E5%9B%9E%E6%83%B3%E8%B5%B7%E8%BF%99%E4%B9%88%E5%A4%9A%E7%9C%8B%E5%88%B0%E8%BF%99%E9%87%8C%E4%BD%A0%E6%98%AF%E5%90%A6%E5%92%8C%E6%88%91%E4%B8%80%E6%A0%B7%E8%A7%89%E5%BE%97%E8%BF%99%E4%BA%9B%E9%83%BD%E6%98%AF%E6%88%91%E4%BB%AC%E6%97%A5%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84%E4%BD%86%E6%98%AF%E6%B7%B1%E7%A9%B6%E5%85%B6%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E5%8F%88%E8%A7%89%E5%BE%97%E5%A5%BD%E5%83%8F%E5%8F%AA%E8%83%BD%E8%AF%B4%E7%82%B9%E7%9A%AE%E6%AF%9B-%E6%B2%A1%E5%85%B3%E7%B3%BB%E4%B8%8B%E9%9D%A2%E6%98%AF%E6%88%91%E6%95%B4%E7%90%86%E7%9A%84%E8%B5%84%E6%96%99%E5%B8%8C%E6%9C%9B%E5%AF%B9%E5%90%84%E4%BD%8D%E5%86%8D%E6%AC%A1%E9%9D%A2%E8%AF%95%E7%9A%84%E6%97%B6%E5%80%99%E6%9C%89%E7%94%A8">** 暂时只能回想起这么多，看到这里你是否和我一样觉得这些都是我们日常用到的，但是深究其底层原理，又觉得好像只能说点皮毛。没关系，下面是我整理的资料，希望对各位再次面试的时候有用！**</a></li>
</ul>
</li>
<li><a href="#%E9%9D%A2%E8%AF%95%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90">面试题目解析</a>
<ul>
<li><a href="#1-%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96">1. 前端性能优化</a>
<ul>
<li><a href="#%E5%87%8F%E5%B0%8F%E4%BB%A3%E7%A0%81%E4%BD%93%E7%A7%AF">减小代码体积</a>
<ul>
<li><a href="#%E9%A6%96%E5%85%88%E6%98%AF%E5%BC%80%E5%8F%91%E6%97%B6%E6%88%91%E4%BB%AC%E4%B8%BB%E8%A6%81%E5%AF%B9%E8%87%AA%E5%B7%B1%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E6%9C%89%E8%AE%A4%E7%9F%A5%E6%80%8E%E4%B9%88%E5%86%99%E6%89%8D%E8%83%BD%E5%81%9A%E5%88%B0%E4%BB%A3%E7%A0%81%E9%87%8F%E6%9C%80%E5%B0%8F%E5%B9%B6%E4%B8%94%E6%89%A7%E8%A1%8C%E7%9A%84%E6%9B%B4%E5%BF%AB">首先是开发时，我们主要对自己代码的执行有认知，怎么写，才能做到代码量最小并且执行的更快。</a></li>
<li><a href="#%E5%85%B6%E6%AC%A1%E5%B0%B1%E6%98%AF-webpack-%E4%B8%BA%E6%88%91%E4%BB%AC%E6%8F%90%E4%BE%9B%E7%9A%84%E6%96%B9%E6%B3%95%E6%88%91%E4%BB%AC%E5%B0%BD%E7%AE%A1%E4%BD%BF%E7%94%A8%E5%8D%B3%E5%8F%AF">其次就是 <code>webpack</code> 为我们提供的方法，我们尽管使用即可</a></li>
<li><a href="#web%E5%9F%BA%E7%A1%80%E4%BC%98%E5%8C%96">web基础优化</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#2-%E6%8F%92%E6%A7%BD">2. 插槽</a></li>
<li><a href="#3-%E5%AD%90%E7%88%B6%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F">3. 子父组件生命周期的加载顺序</a></li>
<li><a href="#4-history-%E5%92%8C-hash-%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E5%8E%9F%E7%90%86">4. <code>history</code> 和 <code>hash</code> 区别以及原理</a><br>
*
<ul>
<li><a href="#%E4%B8%A4%E8%80%85%E5%AF%B9%E6%AF%94">两者对比</a></li>
</ul>
</li>
<li><a href="#5-es6%E7%9A%84map">5. ES6的map</a></li>
<li><a href="#6-%E8%81%8A%E4%B8%80%E4%B8%8Bes5%E5%92%8Ces6%E7%BB%A7%E6%89%BF">6. 聊一下ES5和ES6继承</a></li>
<li><a href="#7-%E7%BB%84%E4%BB%B6%E9%97%B4%E5%A6%82%E4%BD%95%E4%BC%A0%E5%80%BC">7. 组件间如何传值</a></li>
<li><a href="#8-vuex%E5%A6%82%E6%9E%9C%E5%AE%9E%E7%8E%B0%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E8%AF%A6%E7%BB%86%E6%8F%8F%E8%BF%B0%E4%B8%80%E4%B8%8B%E5%AE%9E%E7%8E%B0%E8%BF%87%E7%A8%8B">8. vuex如果实现状态管理，详细描述一下实现过程</a></li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">下一篇</div>
            <a href="https://zhi-he.github.io/post/ge-ren-bo-ke-de-chong-yao-xing/">
              <h3 class="post-title">
                个人博客的重要性
              </h3>
            </a>
          </div>
        

        
          
            <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">
<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<div id="gitalk-container"></div>

<script>

  var gitalk = new Gitalk({
    clientID: 'ef1603f190a7229ea2e9',
    clientSecret: 'f9d9030a1b3ae3666da2bb49c29b0fc8d1117670',
    repo: 'zhi-he.github.io',
    owner: 'zhi-he',
    admin: ['zhi-he'],
    id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
    distractionFreeMode: false  // Facebook-like distraction free mode
  })

  gitalk.render('gitalk-container')

</script>

          

          
        

        <div class="site-footer">
  Powered by <a href="https://zhi-he.github.io" target="_blank">一介码农</a>
  <a class="rss" href="https://zhi-he.github.io/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
